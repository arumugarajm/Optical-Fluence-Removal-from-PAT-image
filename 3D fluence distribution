%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   demo script for mesh generation from binary volumetric image
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clc;
clear all;
addpath('/media/fistlab/DATA/breast dataset/iso2mesh-1.9.6-allinone/iso2mesh-1.9.6');
%% preparation
% user must add the path of iso2mesh to matlab path list
% addpath('../');

% user need to add the full path to .../iso2mesh/bin directory
% to windows/Linux/Unix PATH environment variable

%% load the sample data
load rat_head.mat
% load d2.mat
% volimage is a volumetric image such as an X-ray or MRI image
% A,b are registration matrix and vector, respectively
%% perform mesh generation

%% use the alternative 'cgalmesh' method. This will call 
% cgalmesher to process labled volume to produce surfaces
% and tetrahedral mesh in a single run.
clear opt
opt.radbound=1;
[node,elem,face]=v2m(uint8(volimage),0.5,opt,100,'cgalmesh');


%% visualize the resulting mesh

plotmesh(node,face(:,1:3));
axis equal;

%% edited by me
%%

% frequency=0;
N=node;
[row,col,ch]=size(node);
Xim = volimage;
[ROW,COL,WID] = size(Xim);
[rowim,colim,chim]=size(N);
% Znew=reshape(Z,row*3,1);% reshaping the vertex matrix
 X=N(:,1);% seperating x coordinates from Z
 Y=N(:,2);% seperating y coordinates from Z
 Z=N(:,3);
 E1=ceil(X);E2=floor(X);% finding min and max values of X & Y coorinate matrices
 F1=ceil(Y);F2=floor(Y);
 G1=ceil(Z);G2=floor(Z);

 
  for i=1:row   % ceil will make index of matrix to 0 to avoid change to 1
     if E1(i)==0
         E1(i)=1;
     elseif E2(i)==0
         E2(i)=1;
     end
     if F1(i)==0
         F1(i)=1;
     elseif F2(i)==0
         F2(i)=1;
     end
     if G1(i)==0
         G1(i)=1;
     elseif G2(i)==0
         G2(i)=1;
     end
  end
 
 
 for i=1:row   % floor will make index of matrix to greater than row max to avoid change to 1
     if E1(i)>rowim
         E1(i)=rowim;
     elseif E2(i)>rowim
         E2(i)=rowim;
     end
     if F1(i)>rowim
         F1(i)=rowim;
     elseif F2(i)>rowim
         F2(i)=rowim;
     end
     
      if G1(i)>rowim
         G1(i)=rowim;
     elseif G2(i)>rowim
         G2(i)=rowim;
     end
 end
 D1=zeros(row,1);% assigning matrix sizes before work with for loop
 D2=zeros(row,1);
 D3=zeros(row,1);
 D4=zeros(row,1);
 D5=zeros(row,1);
 D6=zeros(row,1);
 D7=zeros(row,1);
 D8=zeros(row,1);
 
pxmin=min(node(:,1)); % min & max values in X & Y coorinates
pymin=min(node(:,2));
pzmin=min(node(:,3));
pxmax=max(node(:,1));
pymax=max(node(:,2));
pzmax=min(node(:,3));

for i=1:row
D1(i)=sqrt((X(i)-E1(i))^2+(Y(i)-F1(i))^2 +(Z(i)-G1(i))^2 );%formula for distance measurement
D2(i)=sqrt((X(i)-E1(i))^2+(Y(i)-F1(i))^2+(Z(i)-G2(i))^2 );
D3(i)=sqrt((X(i)-E1(i))^2+(Y(i)-F2(i))^2+(Z(i)-G1(i))^2 );
D4(i)=sqrt((X(i)-E1(i))^2+(Y(i)-F2(i))^2+(Z(i)-G2(i))^2 );
D5(i)=sqrt((X(i)-E2(i))^2+(Y(i)-F1(i))^2 +(Z(i)-G1(i))^2 );
D6(i)=sqrt((X(i)-E2(i))^2+(Y(i)-F1(i))^2+(Z(i)-G2(i))^2 );
D7(i)=sqrt((X(i)-E2(i))^2+(Y(i)-F2(i))^2+(Z(i)-G1(i))^2 );
D8(i)=sqrt((X(i)-E2(i))^2+(Y(i)-F2(i))^2+(Z(i)-G2(i))^2 );
end

Ximn=zeros(row,1);%To store the pixel values as a vector
o=zeros(row,1);%To store the boundary vertex
for i=1:row  % checking which point is nearer to the original image index postion
if (D1(i)<D2(i))&&(D1(i)<D3(i))&&(D1(i)<D4(i))&&(D1(i)<D5(i))&&(D1(i)<D6(i))&&(D1(i)<D7(i))&&(D1(i)<D8(i))
    Ximn(i) = Xim(E1(i),F1(i),G1(i));
elseif(D2(i)<D1(i))&&(D2(i)<D3(i))&&(D2(i)<D4(i))&&(D2(i)<D5(i))&&(D2(i)<D6(i))&&(D2(i)<D7(i))&&(D2(i)<D8(i))
    Ximn(i) = Xim(E1(i),F1(i),G2(i));
elseif(D3(i)<D1(i))&&(D3(i)<D2(i))&&(D3(i)<D4(i))&&(D3(i)<D5(i))&&(D3(i)<D6(i))&&(D3(i)<D7(i))&&(D3(i)<D8(i))
    Ximn(i) = Xim(E1(i),F2(i),G1(i));
elseif(D4(i)<D1(i))&&(D4(i)<D2(i))&&(D4(i)<D3(i))&&(D4(i)<D5(i))&&(D4(i)<D6(i))&&(D4(i)<D7(i))&&(D4(i)<D8(i))
    Ximn(i) = Xim(E1(i),F2(i),G2(i));
elseif(D5(i)<D1(i))&&(D5(i)<D2(i))&&(D5(i)<D3(i))&&(D5(i)<D4(i))&&(D5(i)<D6(i))&&(D5(i)<D7(i))&&(D5(i)<D8(i))
    Ximn(i) = Xim(E2(i),F1(i),G1(i));
elseif(D6(i)<D1(i))&&(D6(i)<D2(i))&&(D6(i)<D3(i))&&(D6(i)<D5(i))&&(D6(i)<D4(i))&&(D6(i)<D7(i))&&(D6(i)<D8(i))
    Ximn(i) = Xim(E2(i),F1(i),G2(i));
elseif(D7(i)<D1(i))&&(D7(i)<D2(i))&&(D7(i)<D3(i))&&(D7(i)<D5(i))&&(D7(i)<D6(i))&&(D7(i)<D4(i))&&(D7(i)<D8(i))
    Ximn(i) = Xim(E2(i),F2(i),G1(i));
elseif(D8(i)<D1(i))&&(D8(i)<D2(i))&&(D8(i)<D3(i))&&(D8(i)<D5(i))&&(D8(i)<D6(i))&&(D8(i)<D7(i))&&(D8(i)<D4(i))
    Ximn(i) = Xim(E2(i),F2(i),G2(i));
 else
     Ximn(i) =  Xim(E2(i),F2(i),G2(i));
end

if (pxmin==node(i,1)) % finding boundary vertex. just finding extreme points in the rectangle
    o(i)=1;
elseif(pymin==node(i,2))
    o(i)=1;
elseif(pzmin==node(i,3))
    o(i)=1;
elseif (pxmax==node(i,1))
    o(i)=1;
elseif (pymax==node(i,2))
    o(i)=1;
elseif(pzmax==node(i,3))
    o(i)=1;
end
end

% u=zeros(row,1);
vertn=0.125*0.5*0.5*[X Y Z];% generating node points according to NIRFAST


ksi=0.2129*ones(row,1);
c=2.255*10^11*ones(row,1);
kappa=0.33*ones(row,1);
ri=1.33*ones(row,1);
mus=ones(row,1);
num=[1;2;3;4;5;6;7;8;9;10];%10 sources
% num=[1;2;3;4;5;6;7;8;9;10;11;12];%12 sources

coord = 0.125*0.5*0.5*[58.9474 255.666 0; 300.255 116.663 0; 461.156 56.6 0; 615.201 19.9372 0; 615.52 12.9839 0; 614.164 27.9428 0; 99.3564 371.897 0; 213.301 379.039 0; 386.415 353.819 0; 612.05 245.915 0];
% coord = [58.9474 255.666 122.409; 300.255 116.663 22.8619; 461.156 56.6 33.9545; 615.201 19.9372 86.5617; 615.52 12.9839 339.946; 614.164 27.9428 501.587; 99.3564 371.897 350.443; 213.301 379.039 521.796; 386.415 353.819 661.683; 612.05 245.915 709.926];
fwhm=zeros(10,1);%for 10 sources
% fwhm=ones(10,1);%for 10 sources


% v=[1;1;1;1;1;1;1;1;1;1;...
%     2;2;2;2;2;2;2;2;2;2;...
%     3;3;3;3;3;3;3;3;3;3;...
%     4;4;4;4;4;4;4;4;4;4;...
%     5;5;5;5;5;5;5;5;5;5;...
%     6;6;6;6;6;6;6;6;6;6;...
%     7;7;7;7;7;7;7;7;7;7;...
%     8;8;8;8;8;8;8;8;8;8;...
%     9;9;9;9;9;9;9;9;9;9;...
%     10;10;10;10;10;10;10;10;10;10];
% w=[1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10;...
%     1;2;3;4;5;6;7;8;9;10];

v=[1;1;1;1;1;1;1;1;1;...
    2;2;2;2;2;2;2;2;2;...
    3;3;3;3;3;3;3;3;3;...
    4;4;4;4;4;4;4;4;4;...
    5;5;5;5;5;5;5;5;5;...
    6;6;6;6;6;6;6;6;6;...
    7;7;7;7;7;7;7;7;7;...
    8;8;8;8;8;8;8;8;8;...
    9;9;9;9;9;9;9;9;9;...
    10;10;10;10;10;10;10;10;10];
w=[2;3;4;5;6;7;8;9;10;...
    3;4;5;6;7;8;9;10;1;...
    4;5;6;7;8;9;10;1;2;...
    5;6;7;8;9;10;1;2;3;...
    6;7;8;9;10;1;2;3;4;...
    7;8;9;10;1;2;3;4;5;...
    8;9;10;1;2;3;4;5;6;...
    9;10;1;2;3;4;5;6;7;...
    10;1;2;3;4;5;6;7;8;...
    1;2;3;4;5;6;7;8;9];

% x=ones(100,1);
x=ones(90,1);
% x=ones(144,1);

link=[v w x];% link for source and detector
% O = ones(row,1);

%generating mesh, source, meas structures
source.distributed=0;
source.fixed=1;
source.num=num;
source.coord=coord;
source.fwhm=fwhm;

mesh.name='cylinder';
mesh.nodes=vertn(:,1:3);
mesh.bndvtx=o;
mesh.type='stnd';
mesh.mua=Ximn;
% disp(mesh.mua);
mesh.muan=Ximn;
mesh.kappa=kappa;
mesh.ri=ri;
mesh.mus=mus;
mesh.elements=elem(:,1:4);
mesh.dimension=3;
mesh.source=source;
mesh.link=link;
mesh.c=c;
mesh.ksi=ksi;

meas.fixed=1;
meas.num=[1;2;3;4;5;6;7;8;9;10];
% meas.num=[1;2;3;4;5;6;7;8;9;10;11;12];

meas.coord = 0.125*0.5*0.5*[58.9474 255.666 0; 300.255 116.663 0; 461.156 56.6 0; 615.201 19.9372 0; 615.52 12.9839 0; 614.164 27.9428 0; 99.3564 371.897 0; 213.301 379.039 0; 386.415 353.819 0; 612.05 245.915 0];
% meas.coord = [58.9474 255.666 122.409; 300.255 116.663 22.8619; 461.156 56.6 33.9545; 615.201 19.9372 86.5617; 615.52 12.9839 339.946; 614.164 27.9428 501.587; 99.3564 371.897 350.443; 213.301 379.039 521.796; 386.415 353.819 661.683; 612.05 245.915 709.926];
[ind, int_func] = mytsearchn(mesh,mesh.source.coord);
mesh.meas=meas;

r=[ind int_func];
mesh.meas.int_func=r;


data = femdata(mesh,0);
% plotmesh(mesh,1);

S = sum(data.phi,2);% add all the fluence generated by the source.  It add all the columns
format long
S;
min(S);
% S1=zeros(row,1);
S1=full(S);% checking sum and full produce the same result or not


% plotimage(mesh,S1);%plotimage function will plot image for a single variable
new=mesh.mua.*S1;%mua and fluence multiplication
% new=mesh.mua;


% plotmesh1(mesh,new);%plot image for new mua value
mesh.mua=new;%changing mua value to mua*phi
% plotmesh(mesh);%plotting mesh with optical fluence

% k = boundary(Ximn);


 D1n=zeros(row,1);% assigning matrix sizes before work with for loop
 D2n=zeros(row,1);
 D3n=zeros(row,1);
 D4n=zeros(row,1);
 D5n=zeros(row,1);
 D6n=zeros(row,1);
 D7n=zeros(row,1);
 D8n=zeros(row,1);
 
 
for i=1:row
D1n(i)=sqrt((X(i)-E1(i))^2+(Y(i)-F1(i))^2 +(Z(i)-G1(i))^2 );%formula for distance measurement
D2n(i)=sqrt((X(i)-E1(i))^2+(Y(i)-F1(i))^2+(Z(i)-G2(i))^2 );
D3n(i)=sqrt((X(i)-E1(i))^2+(Y(i)-F2(i))^2+(Z(i)-G1(i))^2 );
D4n(i)=sqrt((X(i)-E1(i))^2+(Y(i)-F2(i))^2+(Z(i)-G2(i))^2 );
D5n(i)=sqrt((X(i)-E2(i))^2+(Y(i)-F1(i))^2 +(Z(i)-G1(i))^2 );
D6n(i)=sqrt((X(i)-E2(i))^2+(Y(i)-F1(i))^2+(Z(i)-G2(i))^2 );
D7n(i)=sqrt((X(i)-E2(i))^2+(Y(i)-F2(i))^2+(Z(i)-G1(i))^2 );
D8n(i)=sqrt((X(i)-E2(i))^2+(Y(i)-F2(i))^2+(Z(i)-G2(i))^2 );
end

Ximg=zeros(ROW,COL,WID);

for i=1:row  % checking which point is nearer to the original image index postion
if (D1n(i)<D2n(i))&&(D1n(i)<D3n(i))&&(D1n(i)<D4n(i))&&(D1n(i)<D5n(i))&&(D1n(i)<D6n(i))&&(D1n(i)<D7n(i))&&(D1n(i)<D8n(i))
     Ximg(E1(i),F1(i),G1(i))=mesh.mua(i);
elseif(D2n(i)<D1n(i))&&(D2n(i)<D3n(i))&&(D2n(i)<D4n(i))&&(D2n(i)<D5n(i))&&(D2n(i)<D6n(i))&&(D2n(i)<D7n(i))&&(D2n(i)<D8n(i))
    Ximg(E1(i),F1(i),G2(i))=mesh.mua(i);
elseif(D3n(i)<D1n(i))&&(D3n(i)<D2n(i))&&(D3n(i)<D4n(i))&&(D3n(i)<D5n(i))&&(D3n(i)<D6n(i))&&(D3n(i)<D7n(i))&&(D3n(i)<D8n(i))
    Ximg(E1(i),F2(i),G1(i))=mesh.mua(i);
elseif(D4n(i)<D1n(i))&&(D4n(i)<D2n(i))&&(D4n(i)<D3n(i))&&(D4n(i)<D5n(i))&&(D4n(i)<D6n(i))&&(D4n(i)<D7n(i))&&(D4n(i)<D8n(i))
    Ximg(E1(i),F2(i),G2(i))=mesh.mua(i);
elseif(D5n(i)<D1n(i))&&(D5n(i)<D2n(i))&&(D5n(i)<D3n(i))&&(D5n(i)<D4n(i))&&(D5n(i)<D6n(i))&&(D5n(i)<D7n(i))&&(D5n(i)<D8n(i))
    Ximg(E2(i),F1(i),G1(i))=mesh.mua(i);
elseif(D6n(i)<D1n(i))&&(D6n(i)<D2n(i))&&(D6n(i)<D3n(i))&&(D6n(i)<D5n(i))&&(D6n(i)<D4n(i))&&(D6n(i)<D7n(i))&&(D6n(i)<D8n(i))
    Ximg(E2(i),F1(i),G2(i))=mesh.mua(i);
elseif(D7n(i)<D1n(i))&&(D7n(i)<D2n(i))&&(D7n(i)<D3n(i))&&(D7n(i)<D5n(i))&&(D7n(i)<D6n(i))&&(D7n(i)<D4n(i))&&(D7n(i)<D8n(i))
    Ximg(E2(i),F2(i),G1(i))=mesh.mua(i);
elseif(D8n(i)<D1n(i))&&(D8n(i)<D2n(i))&&(D8n(i)<D3n(i))&&(D8n(i)<D5n(i))&&(D8n(i)<D6n(i))&&(D8n(i)<D7n(i))&&(D8n(i)<D4n(i))
    Ximg(E2(i),F2(i),G2(i))=mesh.mua(i);
 else
     Ximg(E2(i),F2(i),G2(i))=mesh.mua(i);
end
end

im = Xim(:,:,30);
figure;imshow(im,[]);
im1= Ximg(:,:,30);
figure;imshow(im1,[]);
